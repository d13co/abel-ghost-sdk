#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 8 TMPL_UPDATABLE
    // smart_contracts/abel_reader/contract.algo.ts:12
    // export class AbelReader extends Contract {
    txn NumAppArgs
    bz main_adminOnly@9
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    pushbytess 0xd5ab3366 0xc2ed743f // method "getAssetsTiny(uint64[],uint64)(string,string,uint8,string[])", method "get_asset_labels(asset)string[]"
    txna ApplicationArgs 0
    match getAssetsTiny getAssetLabels
    err

main_adminOnly@9:
    // smart_contracts/abel_reader/contract.algo.ts:13
    // @baremethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    intc_0 // 1
    txn OnCompletion
    shl
    pushint 48 // 48
    &
    txn ApplicationID
    &&
    assert // OnCompletion must be one of UpdateApplication, DeleteApplication && can only call when not creating
    // smart_contracts/abel_reader/contract.algo.ts:15
    // log("1")
    pushbytes "1"
    log
    // smart_contracts/abel_reader/contract.algo.ts:16
    // assert(TemplateVar<uint64>("UPDATABLE") === 1 && Txn.sender === Global.creatorAddress);
    intc_3 // TMPL_UPDATABLE
    intc_0 // 1
    ==
    bz main_bool_false@13
    txn Sender
    global CreatorAddress
    ==
    bz main_bool_false@13
    intc_0 // 1
    // smart_contracts/abel_reader/contract.algo.ts:13
    // @baremethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    return

main_bool_false@13:
    intc_1 // 0
    // smart_contracts/abel_reader/contract.algo.ts:13
    // @baremethod({ allowActions: ["UpdateApplication", "DeleteApplication"] })
    return


// smart_contracts/abel_reader/contract.algo.ts::AbelReader.getAssetsTiny[routing]() -> void:
getAssetsTiny:
    intc_1 // 0
    dupn 3
    pushbytes ""
    // smart_contracts/abel_reader/contract.algo.ts:19
    // @abimethod({ readonly: true, onCreate: "allow" })
    txna ApplicationArgs 1
    dupn 2
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    intc_2 // 8
    *
    pushint 2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<asset>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/abel_reader/contract.algo.ts:21
    // for (let idx: uint64 = 0; idx < assetIds.length; idx++) {
    intc_1 // 0

getAssetsTiny_while_top@2:
    // smart_contracts/abel_reader/contract.algo.ts:21
    // for (let idx: uint64 = 0; idx < assetIds.length; idx++) {
    dup
    dig 3
    <
    bz getAssetsTiny_after_while@14
    // smart_contracts/abel_reader/contract.algo.ts:22
    // const asset = assetIds[idx];
    dig 3
    extract 2 0
    dig 1
    intc_2 // 8
    *
    dup2
    intc_2 // 8
    extract3 // on error: index access is out of bounds
    bury 11
    extract_uint64
    dup
    bury 6
    // smart_contracts/abel_reader/contract.algo.ts:23
    // const [_, exists] = op.AssetParams.assetCreator(asset.id);
    asset_params_get AssetCreator
    bury 1
    // smart_contracts/abel_reader/contract.algo.ts:24
    // if (!exists) {
    bnz getAssetsTiny_else_body@5
    // smart_contracts/abel_reader/contract.algo.ts:47-52
    // return {
    //   name: "",
    //   unit_name: "",
    //   decimals: new Uint8(0),
    //   labels: [],
    // };
    pushbytes 0x0007000900000b000000000000
    // smart_contracts/abel_reader/contract.algo.ts:25
    // log(encodeArc4(this.getEmptyAssetTinyLabels()));
    log

getAssetsTiny_after_if_else@13:
    // smart_contracts/abel_reader/contract.algo.ts:21
    // for (let idx: uint64 = 0; idx < assetIds.length; idx++) {
    dup
    intc_0 // 1
    +
    bury 1
    b getAssetsTiny_while_top@2

getAssetsTiny_else_body@5:
    // smart_contracts/abel_reader/contract.algo.ts:27
    // const pv: uint64 = abelAppId !== 0 ? compileArc4(AbelStub).call.has_asset_label({ appId: abelAppId, args: [asset.id, "pv"] }).returnValue : 0
    dig 1
    bz getAssetsTiny_ternary_false@8
    itxn_begin
    pushbytes 0x97f40a8a // method "has_asset_label(uint64,string)uint64"
    itxn_field ApplicationArgs
    dig 8
    itxn_field ApplicationArgs
    pushbytes 0x00027076
    itxn_field ApplicationArgs
    intc_1 // 0
    itxn_field OnCompletion
    dig 1
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    pushbytes 0x151f7c75
    ==
    assert // Bytes has valid prefix
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi

getAssetsTiny_ternary_merge@9:
    // smart_contracts/abel_reader/contract.algo.ts:29
    // name: asset.name.toString(),
    dig 5
    dup
    asset_params_get AssetName
    swap
    bury 10
    assert // asset exists
    // smart_contracts/abel_reader/contract.algo.ts:30
    // unit_name: asset.unitName.toString(),
    dup
    asset_params_get AssetUnitName
    swap
    bury 9
    assert // asset exists
    // smart_contracts/abel_reader/contract.algo.ts:31
    // decimals: new Uint8(asset.decimals),
    asset_params_get AssetDecimals
    assert // asset exists
    itob
    dup
    bitlen
    intc_2 // 8
    <=
    assert // overflow
    extract 7 1
    bury 9
    // smart_contracts/abel_reader/contract.algo.ts:32
    // labels: pv === 0 ? [] as string[] : ["pv"],
    bnz getAssetsTiny_ternary_false@11
    pushbytes 0x0000

getAssetsTiny_ternary_merge@12:
    // smart_contracts/abel_reader/contract.algo.ts:28-33
    // const assetInfo: AssetTinyLabels = {
    //   name: asset.name.toString(),
    //   unit_name: asset.unitName.toString(),
    //   decimals: new Uint8(asset.decimals),
    //   labels: pv === 0 ? [] as string[] : ["pv"],
    // };
    dig 7
    dup
    len
    itob
    extract 6 2
    swap
    concat
    dup
    len
    pushint 7 // 7
    +
    dig 8
    dup
    len
    itob
    extract 6 2
    swap
    concat
    dig 1
    itob
    extract 6 2
    pushbytes 0x0007
    swap
    concat
    dig 1
    len
    uncover 3
    +
    swap
    dig 12
    concat
    swap
    itob
    extract 6 2
    concat
    uncover 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/abel_reader/contract.algo.ts:34
    // log(encodeArc4(assetInfo));
    log
    b getAssetsTiny_after_if_else@13

getAssetsTiny_ternary_false@11:
    // smart_contracts/abel_reader/contract.algo.ts:32
    // labels: pv === 0 ? [] as string[] : ["pv"],
    pushbytes 0x0001000200027076
    b getAssetsTiny_ternary_merge@12

getAssetsTiny_ternary_false@8:
    // smart_contracts/abel_reader/contract.algo.ts:27
    // const pv: uint64 = abelAppId !== 0 ? compileArc4(AbelStub).call.has_asset_label({ appId: abelAppId, args: [asset.id, "pv"] }).returnValue : 0
    intc_1 // 0
    b getAssetsTiny_ternary_merge@9

getAssetsTiny_after_while@14:
    // smart_contracts/abel_reader/contract.algo.ts:19
    // @abimethod({ readonly: true, onCreate: "allow" })
    pushbytes 0x151f7c750007000900000b000000000000
    log
    intc_0 // 1
    return


// smart_contracts/abel_reader/contract.algo.ts::AbelReader.getAssetLabels[routing]() -> void:
getAssetLabels:
    // smart_contracts/abel_reader/contract.algo.ts:40
    // @abimethod({ readonly: true, onCreate: "allow" , name: "get_asset_labels", resourceEncoding: "index" })
    txna ApplicationArgs 1
    len
    intc_0 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    pushbytes 0x151f7c750000
    log
    intc_0 // 1
    return
